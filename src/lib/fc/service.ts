import { FunctionConfig } from './function';
import { LogConfig, AlicloudSls } from '../resource/sls';
import {
  RoleConfig,
  generateRamResourceName,
  extractRoleNameFromArn,
  AlicloudRam,
  isAutoGeneratedRole,
  PolicyStatementConfig,
  CustomPolicyConfig,
} from '../resource/ram';
import { VpcConfig, AlicloudVpc } from '../resource/vpc';
import { NasConfig, AlicloudNas } from '../resource/nas';
import * as definition from '../definition';
import * as _ from 'lodash';
import { FC_NAS_SERVICE_PREFIX, FC_DEFAULT_ROLE, FC_DEFAULT_ROLE_POLICY_STATEMENT, FC_DEFAULT_ROLE_POLICY } from '../static';
import { ServerlessProfile, ICredentials } from '../profile';
import FcDeploy from './fc-deploy';
import { isAutoConfig } from '../definition';
import StdoutFormatter from '../component/stdout-formatter';
import * as yaml from 'js-yaml';
import * as core from '@serverless-devs/core';

export interface ServiceConfig {
  name: string;
  serviceName?: string;
  description?: string;
  internetAccess?: boolean;
  logConfig?: LogConfig | 'auto' | 'Auto';
  role?: string | RoleConfig;
  vpcConfig?: VpcConfig | 'auto' | 'Auto';
  nasConfig?: NasConfig | 'atuo' | 'Auto';
  tracingConfig?: 'Enable' | 'Disable';
  import?: boolean;
  protect?: boolean;
}


export class FcService extends FcDeploy<ServiceConfig> {
  static extractFcRole(role) {
    const [, , , , path] = role.split(':');
    const [, roleName] = path.split('/');
    return roleName;
  }

  readonly hasFunctionAsyncConfig: boolean;
  readonly hasCustomContainerConfig: boolean;
  hasAutoConfig: boolean;
  name: string;

  constructor(serviceConf: ServiceConfig, functionConf: FunctionConfig, serverlessProfile: ServerlessProfile, region: string, credentials: ICredentials, curPath?: string) {
    super(serviceConf, serverlessProfile, region, credentials, curPath);
    if (_.has(this.localConfig, 'vpcConfig') && _.has(this.localConfig.vpcConfig, 'vswitchIds')) {
      // vswitchIds -> vSwitchIds
      // @ts-ignore
      this.localConfig.vpcConfig.vSwitchIds = this.localConfig.vpcConfig.vswitchIds;
      // @ts-ignore
      delete this.localConfig.vpcConfig.vswitchIds;
    }
    this.hasCustomContainerConfig = _.has(functionConf, 'customContainerConfig');
    this.hasFunctionAsyncConfig = _.has(functionConf, 'asyncConfiguration');
    this.hasAutoConfig = false;
    this.name = serviceConf?.name;
  }

  async init(useLocal?: boolean): Promise<void> {
    await this.initRemote('service', this.name);
    await this.initStateful();
    await this.initStatefulAutoConfig();
    await this.initLocal();
    await this.setUseRemote(this.name, 'service', useLocal);
  }

  genStateID(): string {
    return `${this.credentials.AccountID}-${this.region}-${this.name}`;
  }

  validateConfig(): void {
    if (_.isEmpty(this.localConfig)) {
      throw new Error('Please add serviceConfig in your s.yml/yaml');
    }
  }

  async generateServiceRole(): Promise<string> {
    const serviceRole: any = this.localConfig.role;
    const accountID = this.credentials.AccountID;
    // 用户指定 roleArn 时不做任何更新 Role 的处理
    if (_.isString(serviceRole) && !isAutoGeneratedRole(serviceRole)) {
      const roleName: string = extractRoleNameFromArn(serviceRole);
      this.logger.info(StdoutFormatter.stdoutFormatter.using('role', `extracted name is ${roleName}`));
      return serviceRole;
    }
    const attachedPolicies = [];
    const assumeRolePolicy = [
      {
        Action: 'sts:AssumeRole',
        Effect: 'Allow',
        Principal: {
          Service: ['fc.aliyuncs.com'],
        },
      },
    ];
    const needAppendNetworkInterface = (!_.isEmpty(this.localConfig.vpcConfig) || !_.isEmpty(this.localConfig.nasConfig));
    const logConfig = this.localConfig?.logConfig;

    if (_.isString(logConfig)) {
      if (!definition.isAutoConfig(logConfig)) {
        throw new Error('logConfig only support auto/Auto when set to string.');
      }
    } else if (!_.isEmpty(logConfig) && !(logConfig?.project && logConfig?.logstore)) {
      throw new Error('logstore and project must both exist in logConfig');
    }

    let roleName: string;
    let roleDescription: string;
    if (_.isEmpty(serviceRole) || isAutoGeneratedRole(serviceRole)) {
      roleName = FC_DEFAULT_ROLE;
      roleDescription = 'FC使用此角色来访问您在其他云产品中的资源并以此作为函数的执行角色。';
      const needAddPermission = this.hasFunctionAsyncConfig || needAppendNetworkInterface || this.hasCustomContainerConfig || logConfig;
      if (needAddPermission) {
        const statement = FC_DEFAULT_ROLE_POLICY_STATEMENT;
        attachedPolicies.push({
          statement,
          name: FC_DEFAULT_ROLE_POLICY,
          description: '⽤于FC服务⻆⾊的授权策略。',
        });
      }
    } else {
      roleName = serviceRole?.name || generateRamResourceName('fcDeployDefaultRole-', this.localConfig?.name, accountID);

      if (serviceRole && !_.isString(serviceRole)) {
        if (serviceRole?.policies) { attachedPolicies.push(...serviceRole?.policies); }
      }

      if (this.hasFunctionAsyncConfig) {
        attachedPolicies.push('AliyunFCInvocationAccess');

        const mnsPolicyName = generateRamResourceName('AliyunFcGeneratedMNSPolicy-', `${this.region}-${this.name}`, accountID);
        const mnsPolicyStatement: PolicyStatementConfig = {
          Action: [
            'mns:SendMessage',
            'mns:PublishMessage',
          ],
          Resource: '*',
          Effect: 'Allow',
        };
        const mnsPolicy: CustomPolicyConfig = {
          name: mnsPolicyName,
          statement: [mnsPolicyStatement],
        };
        attachedPolicies.push(mnsPolicy);
      }

      if (needAppendNetworkInterface) {
        attachedPolicies.push('AliyunECSNetworkInterfaceManagementAccess');
      }

      if (this.hasCustomContainerConfig) {
        attachedPolicies.push('AliyunContainerRegistryReadOnlyAccess');
      }

      if (definition.isAutoConfig(logConfig)) {
        attachedPolicies.push('AliyunLogFullAccess');
      } else if (!_.isString(logConfig) && logConfig?.project && logConfig?.logstore) {
        const logPolicyName = generateRamResourceName('fcDeployDefaultLogPolicy-', `${this.region}-${this.name}`, accountID);
        const logPolicyStatement: PolicyStatementConfig = {
          Action: [
            'log:PostLogStoreLogs',
          ],
          Resource: `acs:log:*:*:project/${logConfig?.project}/logstore/${logConfig.logstore}`,
          Effect: 'Allow',
        };
        const logPolicy: CustomPolicyConfig = {
          name: logPolicyName,
          statement: [logPolicyStatement],
        };
        attachedPolicies.push(logPolicy);
      }
    }

    if (_.isEmpty(attachedPolicies) && _.isEmpty(serviceRole)) { return undefined; }
    this.logger.info(StdoutFormatter.stdoutFormatter.set('role', roleName));
    this.hasAutoConfig = true;
    const alicloudRam = new AlicloudRam(this.serverlessProfile, this.credentials, this.region);
    try {
      const roleArn = await alicloudRam.makeRole(roleName, undefined, roleDescription, undefined, assumeRolePolicy, attachedPolicies);
      return roleArn;
    } catch (ex) {
      if (ex.code === 'NoPermission') {
        this.logger.debug(`handler role no permission, error: ${ex}`);
        return `acs:ram::${accountID}:role/aliyunfcdefaultrole`;
      }
      throw ex;
    }
  }

  async setStatefulAutoConfig(): Promise<void> {
    const stateID: string = this.genStateID();
    const state: any = await this.getState();
    const statefulAutoConfig: any = state?.statefulAutoConfig || {};
    if (!this.useRemote && this.statefulConfig?.nasConfig && definition.isAutoConfig(this.localConfig?.nasConfig)) {
      Object.assign(statefulAutoConfig, {
        nasConfig: this.statefulConfig.nasConfig,
      });
    }
    if (!this.useRemote && this.statefulConfig?.vpcConfig && (definition.isAutoConfig(this.localConfig?.vpcConfig) || definition.isAutoConfig(this.localConfig?.nasConfig))) {
      Object.assign(statefulAutoConfig, {
        vpcConfig: this.statefulConfig.vpcConfig,
      });
    }
    if (!this.useRemote && this.statefulConfig?.logConfig && definition.isAutoConfig(this.localConfig?.logConfig)) {
      Object.assign(statefulAutoConfig, {
        logConfig: this.statefulConfig.logConfig,
      });
    }
    if (!this.useRemote && this.statefulConfig?.role && _.isEmpty(this.localConfig?.role)) {
      Object.assign(statefulAutoConfig, {
        role: this.statefulConfig.role,
      });
    }
    if (!_.isEmpty(statefulAutoConfig)) {
      this.logger.debug(`Set stateful auto config of ${statefulAutoConfig} into state.`);
      await this.setKVInState(stateID, 'statefulAutoConfig', statefulAutoConfig);
    }
  }

  async generateServiceLog(): Promise<LogConfig> {
    const { logConfig } = this.localConfig;
    if (_.isEmpty(logConfig)) {
      return undefined;
    }
    let resolvedLogConfig: LogConfig;
    if (_.isString(logConfig)) {
      if (definition.isAutoConfig(logConfig)) {
        this.hasAutoConfig = true;
        const aliyunSls = new AlicloudSls(this.serverlessProfile, this.credentials, this.region);
        this.logger.info(StdoutFormatter.stdoutFormatter.using('logConfig: auto', 'fc will try to generate default sls project'));
        resolvedLogConfig = await aliyunSls.createDefaultSls(this.name);
        this.logger.info(`Generated logConfig: \n${yaml.dump(resolvedLogConfig, {
          styles: {
            '!!null': 'canonical', // dump null as ~
          },
          sortKeys: true, // sort object keys
        })}`);
      } else {
        throw new Error('logConfig only support auto/Auto when set to string.');
      }
    } else {
      resolvedLogConfig = {
        project: logConfig.project,
        logstore: logConfig.logstore,
        enableRequestMetrics: logConfig.enableRequestMetrics || false,
        enableInstanceMetrics: logConfig.enableInstanceMetrics || false,
      };
    }
    return resolvedLogConfig;
  }

  async generateServiceVpc(isNasAuto: boolean): Promise<VpcConfig> {
    const { vpcConfig } = this.localConfig;
    if ((_.isNil(vpcConfig) && isNasAuto) || _.isString(vpcConfig)) {
      if (_.isString(vpcConfig)) {
        if (!definition.isAutoConfig(vpcConfig)) {
          throw new Error('vpcConfig only support auto/Auto when set to string.');
        }
      }
      this.hasAutoConfig = true;
      // vpc auto
      this.logger.info(StdoutFormatter.stdoutFormatter.using('vpcConfig: auto', 'fc will try to generate related vpc resources automatically'));
      const alicloudVpc = new AlicloudVpc(this.serverlessProfile, this.credentials, this.region);
      const vpcDeployRes = await alicloudVpc.createDefaultVpc();
      this.logger.info(`Generated vpcConfig: \n${yaml.dump(vpcDeployRes, {
        styles: {
          '!!null': 'canonical', // dump null as ~
        },
        sortKeys: true, // sort object keys
      })}`);
      return {
        vpcId: vpcDeployRes.vpcId,
        securityGroupId: vpcDeployRes.securityGroupId,
        vSwitchIds: [vpcDeployRes.vSwitchId],
      };
    }
    return vpcConfig;
  }

  async generateServiceNas(vpcConfig: VpcConfig, roleArn: string, assumeYes?: boolean): Promise<NasConfig> {
    const { nasConfig } = this.localConfig;
    const alicloudNas = new AlicloudNas(this.serverlessProfile, this.credentials, this.region);
    if (_.isString(nasConfig)) {
      if (definition.isAutoConfig(nasConfig)) {
        this.hasAutoConfig = true;
        this.logger.info(StdoutFormatter.stdoutFormatter.using('nasConfig: auto', 'fc will try to generate related nas file system automatically'));
        const nasDefaultConfig = await alicloudNas.createDefaultNas(`${FC_NAS_SERVICE_PREFIX}${this.name}`, vpcConfig, `/${this.name}`, roleArn, assumeYes);
        this.logger.info(`Generated nasConfig: \n${yaml.dump(nasDefaultConfig, {
          styles: {
            '!!null': 'canonical', // dump null as ~
          },
          sortKeys: true, // sort object keys
        })}`);
        return nasDefaultConfig;
      } else {
        throw new Error('nasConfig only support auto/Auto when set to string.');
      }
    }
    // user-defined nasConfig
    for (const mountPoint of nasConfig?.mountPoints) {
      const ensureVm = core.spinner(`Ensuring nas dir: ${mountPoint.nasDir} in mount point: ${mountPoint.serverAddr}...`);
      try {
        await alicloudNas.ensureNasDir(`${FC_NAS_SERVICE_PREFIX}${this.name}`, mountPoint.nasDir, nasConfig.groupId, nasConfig.userId, vpcConfig, roleArn, mountPoint.serverAddr);
        ensureVm.succeed(`Nas dir: ${mountPoint.nasDir} in mount point: ${mountPoint.serverAddr} exists.`);
      } catch (e) {
        ensureVm.fail(`Ensure nas dir: ${mountPoint.nasDir} in mount point: ${mountPoint.serverAddr} failed.`);
        this.logger.debug(`Ensure nas dir: ${mountPoint.nasDir} in mount point: ${mountPoint.serverAddr} failed, error: ${e}`);
      }
    }

    return nasConfig;
  }

  async makeService(assumeYes?: boolean): Promise<ServiceConfig> {
    if (this.useRemote) {
      this.statefulConfig = _.cloneDeep(this.remoteConfig);
      this.upgradeStatefulConfig();
      return this.remoteConfig;
    }
    if (_.isEmpty(this.localConfig)) {
      this.statefulConfig = null;
      return null;
    }
    const resolvedServiceConf: ServiceConfig = {
      name: this.name,
    };

    if (!_.isNil(this.localConfig.tracingConfig)) {
      Object.assign(resolvedServiceConf, { tracingConfig: this.localConfig.tracingConfig });
    }

    if (!_.isNil(this.localConfig.description)) {
      Object.assign(resolvedServiceConf, { description: this.localConfig.description });
    }

    if (!_.isNil(this.localConfig.internetAccess)) {
      Object.assign(resolvedServiceConf, { internetAccess: this.localConfig.internetAccess });
    }
    const role = await this.generateServiceRole();
    if (!_.isEmpty(role)) { Object.assign(resolvedServiceConf, { role }); }
    if (!_.isEmpty(this.localConfig.logConfig)) {
      const resolvedLogConfig = await this.generateServiceLog();
      Object.assign(resolvedServiceConf, { logConfig: resolvedLogConfig });
    }
    const { nasConfig } = this.localConfig;
    const isNasAuto = definition.isAutoConfig(nasConfig);

    if (!_.isEmpty(this.localConfig.vpcConfig) || isNasAuto) {
      // vpc
      const resolvedVpcConfig = await this.generateServiceVpc(isNasAuto);
      Object.assign(resolvedServiceConf, { vpcConfig: resolvedVpcConfig });
    }
    if (!_.isEmpty(this.localConfig.nasConfig)) {
      // nas
      // @ts-ignore
      const resolvedNasConfig = await this.generateServiceNas(resolvedServiceConf?.vpcConfig, resolvedServiceConf?.role, assumeYes);
      Object.assign(resolvedServiceConf, { nasConfig: resolvedNasConfig });
    }
    if (this.existOnline) {
      Object.assign(resolvedServiceConf, {
        import: true,
        protect: false,
      });
    }
    return resolvedServiceConf;
  }

  async initLocal(): Promise<void> {
    this.validateConfig();
    await this.initLocalConfig();
    this.logger.debug(`local service config is: ${JSON.stringify(this.localConfig, null, '  ')} after init.`);
  }

  private async initLocalConfig(): Promise<void> {
    if (_.isEmpty(this.statefulAutoConfig)) { return; }
    const resolvedAutoConfigInState: any = this.statefulAutoConfig || {};
    // transform nasConfig
    if (resolvedAutoConfigInState?.nasConfig) {
      Object.assign(resolvedAutoConfigInState, {
        nasConfig: {
          userId: resolvedAutoConfigInState.nasConfig.userId,
          groupId: resolvedAutoConfigInState.nasConfig.groupId,
          mountPoints: resolvedAutoConfigInState.nasConfig.mountPoints.map((item) => AlicloudNas.transformMountpointFromRemoteToLocal(item)),
        },
      });
    }
    if (isAutoConfig(this.localConfig.logConfig) ||
      isAutoConfig(this.localConfig.nasConfig) ||
      isAutoConfig(this.localConfig.vpcConfig) ||
      (_.isEmpty(this.localConfig.role) && !_.isEmpty(resolvedAutoConfigInState.role))) {
      this.localConfig.logConfig = (isAutoConfig(this.localConfig.logConfig) && !_.isEmpty(resolvedAutoConfigInState.logConfig)) ? resolvedAutoConfigInState.logConfig : this.localConfig.logConfig;
      this.localConfig.vpcConfig = ((isAutoConfig(this.localConfig.vpcConfig) || isAutoConfig(this.localConfig.nasConfig)) && !_.isEmpty(resolvedAutoConfigInState.vpcConfig)) ? resolvedAutoConfigInState.vpcConfig : this.localConfig.vpcConfig;
      this.localConfig.nasConfig = (isAutoConfig(this.localConfig.nasConfig) && !_.isEmpty(resolvedAutoConfigInState.nasConfig)) ? resolvedAutoConfigInState.nasConfig : this.localConfig.nasConfig;
      this.localConfig.role = (_.isEmpty(this.localConfig.role) && !_.isEmpty(resolvedAutoConfigInState.role) && isAutoGeneratedRole(resolvedAutoConfigInState.role)) ? resolvedAutoConfigInState.role : this.localConfig.role;
    }

    if (this.existOnline) {
      Object.assign(this.localConfig, {
        import: true,
        protect: false,
      });
    }
  }
}
